\chapter{Web-Anwendungen und Serviceorientierte Architekturen (II)}

Zusammenfassung der Vorlesung "`Web-Anwendungen und Serviceorientierte Architekturen (II)"' aus dem Sommersemester 2017.\footnote{\url{https://cm.tm.kit.edu/study_wasa2p.php}}

\section{C\&M-Software-Entwicklung}
\begin{itemize}
	\item Ziele: Stetige Weiterentwicklung der praktizierten Software-Entwicklung; 
\end{itemize}



\section{Domain Modeling}

\subsection{Einführung}
\begin{itemize}
	\item \textbf{Motivation}
	\begin{itemize}
		\item 
	\end{itemize}
\end{itemize}


\subsection{Domain-Driven Design (DDD)}


\subsection{Anwendungen in der Software-Entwicklung}



\section{Microservices and Web APIs}

\subsection{Einführung}
\begin{itemize}
	\item Motivation
	\begin{itemize}
		\item Monolithische Software-Systeme werden immer größer (siehe "`Software-Krise"' von 1968) und komplexer
		\item \textit{System-Zentrierung}: Software-Entwicklung, da hier immer ein Software-System realisiert wird
		\item \textit{Prozess-Zentrierung}: SOA-Entwicklung, da Geschäftsprozesse unterstützt werden sollen
	\end{itemize}
	\item Feingranulare, kooperierende Services, die jeweils individuelle Teilaufgaben übernehmen und individuell entwickelt und deployt werden
	\item \textbf{Beeinflusst durch:}
	\begin{itemize}
		\item Domain-Driven Design
		\item Hexagonale Architektur
		\begin{itemize}
			\item Ziel: Anwendung soll unabhängig von ihrer Laufzeitumgebung testbar sein \(\rightarrow\) Trennung von Geschäftslogik und externen Abhängigkeiten. Funktionalität soll ausschließlich über \texttt{APIs} angesprochen werden können
			\item Hexagonale Darstellung symbolisiert die Schnittstellen ("`Ports and Adapters"'). \textit{Adapter} konvertieren die \textit{Events}, die an den \textit{Ports} eintreffen in Prozeduren
		\end{itemize}
		\item Continuous Delivery (CD) und Build Pipelines
		\begin{itemize}
			\item Jeder Repository-Checkin wird als Release Candidate behandelt, automatisch gebaut und automatisiert getestet
			\item Visualisierung des Zustands
			\item Eine Pipeline pro Microservice
		\end{itemize}
		\item Virtualisierung
		\begin{itemize}
			\item System-Virtualisierung: Hyperviser verwaltet die Gastressourcen. Pro VM ein Betriebssystem mit eigenem Kernel
			\item Container-Virtualisierung: Prozessvirtualisierung mit separatem Prozess pro Container. Ohne Hypervisor; erlaubt schnelleres Provisioning; Container teilen sich den Kernel
		\end{itemize}
	\end{itemize}
	\item \textbf{Beziehung zu \texttt{SOA}}
	\begin{itemize}
		\item Microservices bilden einen bestimmten Ansatz um \texttt{SOA} umzusetzen
		\item Verwendung von Shared Libraries empfehlenswert, erhöhen allerdings auch die Kopplung
	\end{itemize}
\end{itemize}


\subsection{Grundlagen}
\begin{itemize}
	\item \textbf{Eigenschaften/Ziele}
	\begin{itemize}
		\item "`Single-Responsible-Principle"': Jeder Microservice implementiert einen bestimmten Prozess. Idealerweise ein Microservice pro Team, Entwicklungsaufwand sollte zwei Wochen nicht übersteigen
		\item Selbstständigkeit: Ein Microservice pro Gerät \(\rightarrow\) Änderungen am Microservice bleiben auf eine Maschine beschränkt
		\item Kommunikation über \texttt{APIs}
		\item Lose Kopplung: Änderungen an einem Service dürfen keine Auswirkungen auf andere Services haben \(\rightarrow\) reduziert den Verwaltungsaufwand
		\item Hohe Kohäsion: Für jede Aufgabe ist genau ein Service zuständig \(\rightarrow\) Änderungen betreffen lediglich einen Service (siehe "`Single-Responsible-Principle"')
	\end{itemize}
	\item \textbf{Backends for Frontends (BFFs)}
	\begin{itemize}
		\item Serverseitige Backends für UIs (ein Backend pro UI), die unabhängig von einander entwickelt werden können
		\item Weiterentwicklung von API-Gateways
		\item Idealerweise ein Backend pro Team
	\end{itemize}
	\item \textbf{Kommunikationsmöglichkeiten}
	\begin{itemize}
		\item Request-Response-basiert
		\begin{itemize}
			\item Remote Procedure Call (RPC): Stub-basierter Zugriff auf eine entfernte Ressource. Bsp.: \texttt{SOAP}
			\item REpresentational State Transfer (REST): Ressourcen-orientiert und vom internen Speicher entkoppelt; basiert auf \texttt{HTTP}. RESTful \texttt{APIs} müssen die fünf REST-Prinzipien erfüllen
			\begin{enumerate}
				\item Adressierbarkeit von Ressourcen über eindeutige \texttt{URLs}
				\item Veränderungen von Daten nur über eine Repräsentation
				\item Zustandslose Kommunikation
				\item Verschiedene Repräsentationen pro Ressource in Abhängigkeit des Anfragenden
				\item Navigation ausschließlich über \texttt{URLs}, die vom Server bereitgestellt werden
			\end{enumerate}
		\end{itemize}
		\item Event-basiert (Producer-Consumer-Schema): \textit{Message-Brokers} verteilten Event-Nachrichten. Beispiele: \texttt{RabbitMQ} oder \texttt{Apache Kafka}
	\end{itemize}
	\item \textbf{Klassifizierung von \texttt{APIs} nach Richardson}
	\begin{itemize}
		\item Vier verschiedene, hierarchisch angeordnete Typen, die jeweils auf den untergeordneten basieren
		\begin{description}
			\item{Level 3:} Hypermedia (Hypermedia-orientiert)
			\item{Level 2:} Protocol Properties (Ressourcen-orientiert)
			\item{Level 1:} Resources (Ressourcen-orientiert)
			\item{Level 0:} Plain Old XML
		\end{description}
	\end{itemize}
\end{itemize}


\subsection{Design von Web APIs}
\begin{itemize}
	\item Qualitätskriterien: Einfach zu verstehen; Technologie-unabhängig; konsistent; erweiterbar; weiterentwickelbar
	\item \texttt{API} sollte Startpunkt der Entwicklung sein ("`\texttt{API} first"'); Design-Guidelines aufstellen und umsetzen
	\item \textbf{Entwicklungsstrategie: \texttt{API} First}
	\begin{enumerate}
		\item Anforderungen an den Service aufstellen (ableiten aus Analysephase)
		\item Iterativ: Entwickeln/Verbessern der \texttt{API}; Reviewen der \texttt{API}
		\item Service und Consumer entwickeln
	\end{enumerate}
	\item \textbf{\texttt{API} Guideline-Sammlung}
	\begin{itemize}
		\item Ressourcen-orientiert mit einheitlichem Look-and-Feel
		\item Einheitliche Namenssyntax, beispielsweise bei \texttt{HTTP}-Headern oder \texttt{JavaScript}-Objekten
		\item Selbsterklärende Beschreibungen bei URLs zur Ressourcen-Identifikation
		\item Sinnvolle Objektfilter. Bsp.: \texttt{/sales-orders/?filter=(creation\_date=20151106)}
		\item Korrekte Verwendung der \texttt{HTTP}-Methoden
	\end{itemize}
	\item \textbf{OpenAPI}
	\begin{itemize}
		\item Spezifikation zur Definition von RESTful \texttt{APIs}; unterstützt von einigen IT-Konzernen; aus Swagger abgeleitet
		\item \texttt{JSON}- oder \texttt{YAML}-Bschreibung
		\begin{description}
			\item[info:] Metainformationen
			\item[paths:] Endpunkte und Methoden
			\item[definitions:] Zur Wiederverwendung von Objekten
		\end{description}
	\end{itemize}
	\item \textbf{Swagger}
	\begin{itemize}
		\item Stellt Werkzeuge zum Testen und zur Dokumentation von OpenAPI-beschriebenen \texttt{APIs} zur Verfügung
		\item Swagger Editor: Erstellen/Verändern von \texttt{APIs}
		\item Swappger Codegen: Erstellen von Software-Stubs
		\item Swagger UI: Automatisches Erzeugen von Dokumentation
	\end{itemize}
	\item \textbf{Schematischer Ansatz zum Entwickeln von Web \texttt{APIs}}
	\begin{itemize}
		\item Grundlage: Domänen-Modell, Feature-Liste, UI-Entwürfe
		\item Identifikation von Ressourcen: Jedes Domänen-Objekt ist eine potentielle Ressource
		\item Abgleich mit der \textit{Humane Service Registry} zum Wiederverwenden existierender \texttt{APIs}
		\item Implementierung der Ressourcen-CRUD-Methoden mittels \texttt{HTTP}-Methoden
		\item Implementierung von URL-Attributen zum Sortieren, Filtern, etc.
	\end{itemize}
\end{itemize}


\subsection{API Management}
\begin{itemize}
	\item Motivation: ZentralesVerwalten, Dokumentieren, Weiterentwickeln, Wiederverwenden von \texttt{APIs}
	\item \textbf{Service Registry}
	\begin{itemize}
		\item Zentrale Verwaltungskomponente; \textit{Service Provider} publisht \texttt{APIs}, \textit{Service Consumer} sucht \texttt{APIs}
		\item Beispiel: \textit{Humane Service Registry} (HSR) aller \texttt{APIs}, die bei C\&M entwickelt worden sind. Attribute sind u.a. Name, Beschreibung und Service-Gruppe
	\end{itemize}
	\item Bestandteile einer \texttt{API}-Managementumgebung: Management, Administrationsportal, Entwicklerportal, \texttt{API}-Microgateway
	\item \texttt{API}-Lifecycle: Design, Secure, Deploy, Publish, Analyze, Operate
	\item \textbf{\texttt{API}-Proxy}
	\begin{itemize}
		\item Verbindet \texttt{API} und Anwendung
		\item Policies: Sicherheit, Traffic-Management, Vermittlung, Erweiterungen
		\item Anwedungsfälle: JSON-Threat-Protection, Quotas, Caching, Frontend einer Microservice-Umgebung, Anfragenlimitierung (Consumer muss ggf. bekannt sein)
		\item Kann Authentifizierung per (externem) \texttt{OAuth2.0}-Server vornehmen
	\end{itemize}
\end{itemize}



\section{ConnectedCar}

\subsection{Einführung}
\begin{itemize}
	\item Trends im Automotive-Geschäftsbreich: Viele "`Innovative"' Lösungen rund um das vernetzte Fahrzeug; technologischer Fortschritt (Hardware, Sensorik, Software, etc.); IT-Unternehmen drängen in den Markt
	\item Herausforderungen: Echtzeitereignisprocessing, Sicherheit, IAM
	\item \texttt{HERE}: Entwicklung von Schnittstellenspezifikation für ConnctedCars. Beispiele: Real Time Traffic; On-Street Parking; Road Signs; Hazard Warnings
	\item \textbf{Gefahrenwarndienst: HazardWarningServiceGroup (HazSG)}
	\begin{itemize}
		\item Warnt vor potentiellen Gefahren (Aquaplaning, Blitzeis, Verkehrsstaus, Unfälle, etc.)
		\item Dienst erhält Ereignisse vom Fahrzeug und sendet im Gegenzug Gehfahreninformationen
	\end{itemize}
	\item \textbf{Complex Event Processing (CEP)}
	\begin{itemize}
		\item Definition Ereignis: "`feingranulare, diskrete Ereignisse"' (bspw. Temperaturveränderung) versus "`grobgranulares Ereignis"' (Glatteiswarnung, Umleitungsempfehlung)
		\item Typisierung von Ereignissen
		\item Verarbeitung von kontinuierlichen Ereignissen in Echtzeit
		\item Mustererkennung: \texttt{[Temperatur < 0]} \(+\) \texttt{[Räder blockieren]} \(\rightarrow\) \texttt{[Blitzeis]}
		\item Esper: CEP-System für Java
		\begin{itemize}
			\item Untersuchen von Datenströmen mittels Event-Processing-Language oder Pattern Matching
			\item Erzeugen von komplexen (kompositen) Ereignistypen
			\item Dynamische Veränderung der Informationsauswertung zur Laufzeit
		\end{itemize}
		\item Aufbau eines \texttt{CEP}-Systems
		\begin{itemize}
			\item Ereignismodell: Definiert Typen und Attribute von Ereignissen
			\item Übertragungskanäle: Verschiedene Technologien möglich, i.d.R. ereignisgetriebene Subscriber-Publisher-Systeme. Beipsielsweise \texttt{RabbitMQ} oder Apache Kafka
			\item Ereignisverarbeitung durch \textit{Event Processing Agents} (EPA): Durchsuchen den Ereignisstrom nach Mustern
		\end{itemize}
		\item Streaming Technologien
		\begin{itemize}
			\item Apache Kafka: Topic-gestützte Verteilung von Ereignisobjekten von Quellen auf Konsumenten; Zusammenfassen von Konsumenten zu \textit{Consumer Groups}
			\item Spring Cloud Stream: Framework für ereignisgesteuerte Microservices. Abstrahiert die Streaming-Middleware (beispielsweise Apache Kafka); direkte Verbindung zwischen Anwendungen möglich (steigert die Effizienz)
		\end{itemize}
	\end{itemize}
	\item \textbf{Ergeignisverarbeitung in der ConnectedCar-Domäne}
	\begin{itemize}
		\item Im Fahrzeug: Entlastung des Backends; Echtzeitanforderungen; Hochverfügbarkeit; Datenschutz
		\item Im Backend: Kombinierbarkeit mit anderen Fahrzeugen; Änderung der Verfahren; Hinzuziehen weiterer Quellen
		\item Ereignisvorverarbeitung im Fahrzeug: Entlastung von Infrastruktur/Backend; dynamische Konfigurierbarkeit durch das Backend möglich (beispielsweise durch gezielte Anfragen)
	\end{itemize}
\end{itemize}


\subsection{Analyse und Entwurf}
\begin{itemize}
	\item Domänenmodell als Grundlage zur Web-\texttt{APIs}, die für den \texttt{HazardWarningService} notwendig sind
	\item \textbf{Vorgehen}
	\begin{enumerate}
		\item Kapselung des Domänenmodells in Services
		\item Ermittlung der notwendigen Service-Operationen pro Service (statische \texttt{API}-Spezifikation)
		\item Ergänzen der dynamischen Inhalte, bei beispielsweise ablaufbeschreibende Diagramme (dynamische \texttt{API}-Spezifikation)
	\end{enumerate}
\end{itemize}



\section{Web Services with Quality}

\subsection{Softwarequalität}
\begin{itemize}
	\item \textbf{Motivation}
	\begin{itemize}
		\item Definition: Grad, zu dem Software die Erwartungen unter bestimmten Bedingungen erfüllt
		\item Wichtig um ein gegebenes Problem zu lösen; Katastrophen zu verhindern; Wartungskosten einzusparen
	\end{itemize}
	\item \textbf{Produktqualitätsmodel (ISO/IEC 25010:2011)}
	\begin{itemize}
		\item Klassifizierung von acht Haupteigenschaften, die weiter unterteilt werden
		\item Eigenschaften
		\begin{itemize}
			\item Funktionale Eignung: Zu welchem Grad werden die Voraussetzungen erfüllt
			\item Leistungsfähigkeit
			\item Benutzbarkeit: Wirksamkeit, Effizienz, Zufriedenheit
			\item Kompatibilität: Zusammenarbeit mit anderen Produkten
			\item Zuverlässigkeit: Unter bestimmten Bedingungen für einen vorgegebenen Zeitraum
			\item Sicherheit: IAM
			\item Wartbarkeit
			\item Portierbarkeit
		\end{itemize}
	\end{itemize}
	\item \textbf{Qualitätsmetamodell}
	\begin{itemize}
		\item \textit{Quality Characteristic}: Kategorie von Qualitätsattributen (beispielsweise Wartbarkeit); kann in mehrere \textit{Quality sub-characteristics} unterteilt werden
		\item \textit{Quality Attribute}: \texttt{[1..*]} quantifizieren eine \textit{Quality Characteristic}
		\item \textit{Quality Criterion}: Zufriedenheitsschwelle pro \textit{Quality Attribute}
		\item \textit{Quality indicator}: Weist auf die Umsetzung von \textit{Quality Attributes} hin; kann aus Design Pattern, Best Practices, etc. abgeleitet werden
		\item \textit{Quality Metric}: Formalisiert \textit{Quality Indicators}
	\end{itemize}
\end{itemize}


\subsection{Qualitätsindikatoren für Webservices}
\begin{itemize}
	\item \textbf{Best Pratices für RESTful Webservices}
	\begin{itemize}
		\item Fokus auf Wartbarkeit/Benutzbarkeit
		\item Versionierung
		\begin{itemize}
			\item Möglichkeiten: Eingebettet in die URL; Verwendung des \texttt{HTTP}-Headers
			\item RESTful Webservices müssen nicht versioniert werden (wegen des Hypermedia-Gedankens)
		\end{itemize}
		\item Beschreiben von Ressourcen
		\begin{itemize}
			\item Verwendung von domänenspezifischen Substantiven, beispielsweise in Anlehnung an die \texttt{Javascript}-Nameconventions
			\item Vermeiden von unnötigen Bezeichnungen/Ressourcen
			\item Vermeiden Plural-Singular-Mischformen
		\end{itemize}
		\item Fehlerbehandlung
		\begin{itemize}
			\item Fehlermeldungen müssen klar und verständlich sein
			\item Spezifische Nutzung von \texttt{HTTP}-Fehlercodes ("`Antwort-Code"')
			\item Inhalt einer Fehlermeldung: Separate Meldung für Entwickler und Benutzer; anwendungsspezifischer Fehlercode ("`Fehler-Code"'); Link zu weiteren Informationen
		\end{itemize}
	\end{itemize}
\end{itemize}



\section{API-Spezifikationen}

\subsection{Einführung}
\begin{itemize}
	\item Motivation: Wichtiges Unternehmensgut; kann nicht mehr verwendet werden, wenn veröffentlicht (ggf. hohe Supportkosten)
	\item \textbf{Qualitätsmerkmale}
	\begin{itemize}
		\item Kundensicht: Einfach zu verstehen/nutzen
		\item Unabhängig von Technologien/Anwendungsfällen (\texttt{API}-First)
		\item Konsistent und erweiterbar (iterative Entwicklung mit Experten)
	\end{itemize}
	\item Unterscheidung zwischen Backend-Service-APIs (kapseln Geschäftslogik) und Backend-For-Frontend-APIs (kapseln mehrere Backend-Service-APIs: Feature-orientiert, UI-orientiert)
	\item Hpermedia-Aspekt wird meist ignoriert: Pfadtypen werden "`hard-codiert"'
\end{itemize}

\subsection{Entwurf von Backend-Service-APIs}
\begin{enumerate}
	\item Analysieren der bestehenden Analyse-und Entwicklungsartefakte
	\item Identifikation von Ressourcen
	\item Ressourcen in \textit{Humane Service Registry} nachschauen und ggf. ergänzen
\end{enumerate}



\section{Scrum}

\subsection{Einführung}
\begin{itemize}
	\item Komplexere Anforderungen/Erwartungen erfordern moderne Methoden in der Softwareentwicklung
	\item Eigenschaften agiler Methoden: Iterativ; inkrementell; mehr Kundenwert in kürzerer Zeit; basieren auf dem \textit{Agilen Manifest (2001)}
	\item Beispiele: Extrem Programming (XP); Kanban
	\item \textbf{Scrum}
	\begin{itemize}
		\item Ziel: Geregelte Zusammenarbeit in selbstorganisierenden Teams
		\item Komplexitätsreduktion durch Transparenz; Inspektion; Adaption
		\item Sprints: Regelmäßiges, kurzes Intervall (2-3 Wochen), in der UserStories umgesetzt werden. Ergebnis ist ein lauffähiges Produktinkrement (vollständig umgesetzt und getestet)
	\end{itemize}
\end{itemize}


\subsection{Rollen}
\begin{itemize}
	\item ProductOwner: Verantwortlich für Rentabilität; Produktvision; Überwachen der Qualität; Produktpflege; Releases. Allerdings kein Projektleiter
	\item ScrumMaster: Teamcoach, der das Entwicklungsteam extern vertritt und für das Gelingen verantwortlich ist. Verwaltet das \textit{Impediment Backlog}
	\item Entwicklungsteam: Selbstorganisierte Umsetzung der Softwareanforderungen in Teams von zwei bis 7 Personen; Verantwortlich für Qualität. Auch kein Projektleiter
\end{itemize}


\subsection{Artefakte}
\begin{itemize}
	\item \textbf{Product Backlog}
	\begin{itemize}
		\item Priorisierte Anforderungsliste in Form von UserStories
		\item ProductOwner sortiert die Liste nach Geschäftswert
		\item Meist: Aufsplitten der UserStories beim Wandern "`nach oben"'
		\item \texttt{DEEP}-Kriterien für ein gutes Product Backlog
		\begin{description}
			\item[Details:] Hinreichend detailliert
			\item[Estimated:] Geschäftswert schätzbar
			\item[Emergent:] Wachstum und Veränderung
			\item[Prioritized:] Nach Priorisierung sortiert
		\end{description}
		\item Überarbeitung der Sortierung in \textit{Grooming-Meetings} (kein offizieller Bestandteil von Scum)
	\end{itemize}
	\item \textbf{User Stories}
	\begin{itemize}
		\item Feature aus User-Sicht in ein bis zwei kurzen Sätzen: Wer?, Was?, Warum?
		\item Bestandteile: Id, Aufwand in \textit{Story Points}, Akzeptanzkriterien
	\end{itemize}
	\item \textbf{Planning Poker}
	\begin{itemize}
		\item Aufwandschätzung einer UserStory; kein spezifische Methode von Scrum vorgschrieben, \textit{Planning Poker} wird häufig eingesetzt
		\item Alle Teammitglieder geben unabhängig Schätzungen ab; Extrema müssen ihren Standpunkt erklären; Wiederholen bis Konsens gefunden
	\end{itemize}
	\item \textbf{Sprint Backlog}
	\begin{itemize}
		\item Enthält: Alle UserStories des aktuellen Sprints sowie die abgeleiteten Aufgaben
		\item Visualisiert durch (virtuelles) Taskboard \(\rightarrow\) schafft Transparenz
	\end{itemize}
	\item Impediment Backlog: ScrumMaster-geführtes Backlog, in dem alle Probleme, die während des DailyScrum auftreten, gelistet werden
	\item \textbf{Charts}
	\begin{description}
		\item[Burndown-Chart:] Zeigt den Restaufwand innerhalb eines Sprints
		\item[Velocity-Chart:] Zeigt die Leistungsfähigkeit des Teams in StoryPoints pro Sprint
	\end{description}
\end{itemize}


\subsection{Meetings}


\subsection{Agile Entwicklung mit Scrum}



\section{Sicherheit}