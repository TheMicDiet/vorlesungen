\chapter{Web-Anwendungen und Serviceorientierte Architekturen (II)}

Zusammenfassung der Vorlesung "`Web-Anwendungen und Serviceorientierte Architekturen (II)"' aus dem Sommersemester 2017.\footnote{\url{https://cm.tm.kit.edu/study_wasa2p.php}}

\section{C\&M-Software-Entwicklung}
\begin{itemize}
	\item Ziele: Stetige Weiterentwicklung der praktizierten Software-Entwicklung; 
\end{itemize}



\section{Domain Modeling}

\subsection{Einführung}
\begin{itemize}
	\item \textbf{Motivation}
	\begin{itemize}
		\item 
	\end{itemize}
\end{itemize}


\subsection{Domain-Driven Design (DDD)}


\subsection{Anwendungen in der Software-Entwicklung}



\section{Microservices and Web APIs}

\subsection{Einführung}
\begin{itemize}
	\item Motivation
	\begin{itemize}
		\item Monolithische Software-Systeme werden immer größer (siehe "`Software-Krise"' von 1968) und komplexer
		\item \textit{System-Zentrierung}: Software-Entwicklung, da hier immer ein Software-System realisiert wird
		\item \textit{Prozess-Zentrierung}: SOA-Entwicklung, da Geschäftsprozesse unterstützt werden sollen
	\end{itemize}
	\item Feingranulare, kooperierende Services, die jeweils individuelle Teilaufgaben übernehmen und individuell entwickelt und deployt werden
	\item \textbf{Beeinflusst durch:}
	\begin{itemize}
		\item Domain-Driven Design
		\item Hexagonale Architektur
		\begin{itemize}
			\item Ziel: Anwendung soll unabhängig von ihrer Laufzeitumgebung testbar sein \(\rightarrow\) Trennung von Geschäftslogik und externen Abhängigkeiten. Funktionalität soll ausschließlich über \texttt{APIs} angesprochen werden können
			\item Hexagonale Darstellung symbolisiert die Schnittstellen ("`Ports and Adapters"'). \textit{Adapter} konvertieren die \textit{Events}, die an den \textit{Ports} eintreffen in Prozeduren
		\end{itemize}
		\item Continuous Delivery (CD) und Build Pipelines
		\begin{itemize}
			\item Jeder Repository-Checkin wird als Release Candidate behandelt, automatisch gebaut und automatisiert getestet
			\item Visualisierung des Zustands
			\item Eine Pipeline pro Microservice
		\end{itemize}
		\item Virtualisierung
		\begin{itemize}
			\item System-Virtualisierung: Hyperviser verwaltet die Gastressourcen. Pro VM ein Betriebssystem mit eigenem Kernel
			\item Container-Virtualisierung: Prozessvirtualisierung mit separatem Prozess pro Container. Ohne Hypervisor; erlaubt schnelleres Provisioning; Container teilen sich den Kernel
		\end{itemize}
	\end{itemize}
	\item \textbf{Beziehung zu \texttt{SOA}}
	\begin{itemize}
		\item Microservices bilden einen bestimmten Ansatz um \texttt{SOA} umzusetzen
		\item Verwendung von Shared Libraries empfehlenswert, erhöhen allerdings auch die Kopplung
	\end{itemize}
\end{itemize}


\subsection{Grundlagen}
\begin{itemize}
	\item \textbf{Eigenschaften/Ziele}
	\begin{itemize}
		\item "`Single-Responsible-Principle"': Jeder Microservice implementiert einen bestimmten Prozess. Idealerweise ein Microservice pro Team, Entwicklungsaufwand sollte zwei Wochen nicht übersteigen
		\item Selbstständigkeit: Ein Microservice pro Gerät \(\rightarrow\) Änderungen am Microservice bleiben auf eine Maschine beschränkt
		\item Kommunikation über \texttt{APIs}
		\item Lose Kopplung: Änderungen an einem Service dürfen keine Auswirkungen auf andere Services haben \(\rightarrow\) reduziert den Verwaltungsaufwand
		\item Hohe Kohäsion: Für jede Aufgabe ist genau ein Service zuständig \(\rightarrow\) Änderungen betreffen lediglich einen Service (siehe "`Single-Responsible-Principle"')
	\end{itemize}
	\item \textbf{Backends for Frontends (BFFs)}
	\begin{itemize}
		\item Serverseitige Backends für UIs (ein Backend pro UI), die unabhängig von einander entwickelt werden können
		\item Weiterentwicklung von API-Gateways
		\item Idealerweise ein Backend pro Team
	\end{itemize}
	\item \textbf{Kommunikationsmöglichkeiten}
	\begin{itemize}
		\item Request-Response-basiert
		\begin{itemize}
			\item Remote Procedure Call (RPC): Stub-basierter Zugriff auf eine entfernte Ressource. Bsp.: \texttt{SOAP}
			\item REpresentational State Transfer (REST): Ressourcen-orientiert und vom internen Speicher entkoppelt; basiert auf \texttt{HTTP}. RESTful \texttt{APIs} müssen die fünf REST-Prinzipien erfüllen
			\begin{enumerate}
				\item Adressierbarkeit von Ressourcen über eindeutige \texttt{URLs}
				\item Veränderungen von Daten nur über eine Repräsentation
				\item Zustandslose Kommunikation
				\item Verschiedene Repräsentationen pro Ressource in Abhängigkeit des Anfragenden
				\item Navigation ausschließlich über \texttt{URLs}, die vom Server bereitgestellt werden
			\end{enumerate}
		\end{itemize}
		\item Event-basiert (Producer-Consumer-Schema): \textit{Message-Brokers} verteilten Event-Nachrichten. Beispiele: \texttt{RabbitMQ} oder \texttt{Apache Kafka}
	\end{itemize}
	\item \textbf{Klassifizierung von \texttt{APIs} nach Richardson}
	\begin{itemize}
		\item Vier verschiedene, hierarchisch angeordnete Typen, die jeweils auf den untergeordneten basieren
		\begin{description}
			\item{Level 3:} Hypermedia (Hypermedia-orientiert)
			\item{Level 2:} Protocol Properties (Ressourcen-orientiert)
			\item{Level 1:} Resources (Ressourcen-orientiert)
			\item{Level 0:} Plain Old XML
		\end{description}
	\end{itemize}
\end{itemize}


\subsection{Design von Web APIs}
\begin{itemize}
	\item Qualitätskriterien: Einfach zu verstehen; Technologie-unabhängig; konsistent; erweiterbar; weiterentwickelbar
	\item \texttt{API} sollte Startpunkt der Entwicklung sein ("`\texttt{API} first"'); Design-Guidelines aufstellen und umsetzen
	\item \textbf{Entwicklungsstrategie: \texttt{API} First}
	\begin{enumerate}
		\item Anforderungen an den Service aufstellen (ableiten aus Analysephase)
		\item Iterativ: Entwickeln/Verbessern der \texttt{API}; Reviewen der \texttt{API}
		\item Service und Consumer entwickeln
	\end{enumerate}
	\item \textbf{\texttt{API} Guideline-Sammlung}
	\begin{itemize}
		\item Ressourcen-orientiert mit einheitlichem Look-and-Feel
		\item Einheitliche Namenssyntax, beispielsweise bei \texttt{HTTP}-Headern oder \texttt{JavaScript}-Objekten
		\item Selbsterklärende Beschreibungen bei URLs zur Ressourcen-Identifikation
		\item Sinnvolle Objektfilter. Bsp.: \texttt{/sales-orders/?filter=(creation\_date=20151106)}
		\item Korrekte Verwendung der \texttt{HTTP}-Methoden
	\end{itemize}
	\item \textbf{OpenAPI}
	\begin{itemize}
		\item Spezifikation zur Definition von RESTful \texttt{APIs}; unterstützt von einigen IT-Konzernen; aus Swagger abgeleitet
		\item \texttt{JSON}- oder \texttt{YAML}-Bschreibung
		\begin{description}
			\item[info:] Metainformationen
			\item[paths:] Endpunkte und Methoden
			\item[definitions:] Zur Wiederverwendung von Objekten
		\end{description}
	\end{itemize}
	\item \textbf{Swagger}
	\begin{itemize}
		\item Stellt Werkzeuge zum Testen und zur Dokumentation von OpenAPI-beschriebenen \texttt{APIs} zur Verfügung
		\item Swagger Editor: Erstellen/Verändern von \texttt{APIs}
		\item Swappger Codegen: Erstellen von Software-Stubs
		\item Swagger UI: Automatisches Erzeugen von Dokumentation
	\end{itemize}
	\item \textbf{Schematischer Ansatz zum Entwickeln von Web \texttt{APIs}}
	\begin{itemize}
		\item Grundlage: Domänen-Modell, Feature-Liste, UI-Entwürfe
		\item Identifikation von Ressourcen: Jedes Domänen-Objekt ist eine potentielle Ressource
		\item Abgleich mit der \textit{Humane Service Registry} zum Wiederverwenden existierender \texttt{APIs}
		\item Implementierung der Ressourcen-CRUD-Methoden mittels \texttt{HTTP}-Methoden
		\item Implementierung von URL-Attributen zum Sortieren, Filtern, etc.
	\end{itemize}
\end{itemize}


\subsection{API Management}
\begin{itemize}
	\item Motivation: ZentralesVerwalten, Dokumentieren, Weiterentwickeln, Wiederverwenden von \texttt{APIs}
	\item \textbf{Service Registry}
	\begin{itemize}
		\item Zentrale Verwaltungskomponente; \textit{Service Provider} publisht \texttt{APIs}, \textit{Service Consumer} sucht \texttt{APIs}
		\item Beispiel: \textit{Humane Service Registry} (HSR) aller \texttt{APIs}, die bei C\&M entwickelt worden sind. Attribute sind u.a. Name, Beschreibung und Service-Gruppe
	\end{itemize}
	\item Bestandteile einer \texttt{API}-Managementumgebung: Management, Administrationsportal, Entwicklerportal, \texttt{API}-Microgateway
	\item \texttt{API}-Lifecycle: Design, Secure, Deploy, Publish, Analyze, Operate
	\item \textbf{\texttt{API}-Proxy}
	\begin{itemize}
		\item Verbindet \texttt{API} und Anwendung
		\item Policies: Sicherheit, Traffic-Management, Vermittlung, Erweiterungen
		\item Anwedungsfälle: JSON-Threat-Protection, Quotas, Caching, Frontend einer Microservice-Umgebung, Anfragenlimitierung (Consumer muss ggf. bekannt sein)
		\item Kann Authentifizierung per (externem) \texttt{OAuth2.0}-Server vornehmen
	\end{itemize}
\end{itemize}



\section{ConnectedCar}

\subsection{Einführung}
\begin{itemize}
	\item Trends im Automotive-Geschäftsbreich: Viele "`Innovative"' Lösungen rund um das vernetzte Fahrzeug; technologischer Fortschritt (Hardware, Sensorik, Software, etc.); IT-Unternehmen drängen in den Markt
	\item Herausforderungen: Echtzeitereignisprocessing, Sicherheit, IAM
	\item \texttt{HERE}: Entwicklung von Schnittstellenspezifikation für ConnctedCars. Beispiele: Real Time Traffic; On-Street Parking; Road Signs; Hazard Warnings
	\item \textbf{Gefahrenwarndienst: HazardWarningServiceGroup (HazSG)}
	\begin{itemize}
		\item Warnt vor potentiellen Gefahren (Aquaplaning, Blitzeis, Verkehrsstaus, Unfälle, etc.)
		\item Dienst erhält Ereignisse vom Fahrzeug und sendet im Gegenzug Gehfahreninformationen
	\end{itemize}
	\item \textbf{Complex Event Processing (CEP)}
	\begin{itemize}
		\item Definition Ereignis: "`feingranulare, diskrete Ereignisse"' (bspw. Temperaturveränderung) versus "`grobgranulares Ereignis"' (Glatteiswarnung, Umleitungsempfehlung)
		\item Typisierung von Ereignissen
		\item Verarbeitung von kontinuierlichen Ereignissen in Echtzeit
		\item Mustererkennung: \texttt{[Temperatur < 0]} \(+\) \texttt{[Räder blockieren]} \(\rightarrow\) \texttt{[Blitzeis]}
		\item Esper: CEP-System für Java
		\begin{itemize}
			\item Untersuchen von Datenströmen mittels Event-Processing-Language oder Pattern Matching
			\item Erzeugen von komplexen (kompositen) Ereignistypen
			\item Dynamische Veränderung der Informationsauswertung zur Laufzeit
		\end{itemize}
		\item Aufbau eines \texttt{CEP}-Systems
		\begin{itemize}
			\item Ereignismodell: Definiert Typen und Attribute von Ereignissen
			\item Übertragungskanäle: Verschiedene Technologien möglich, i.d.R. ereignisgetriebene Subscriber-Publisher-Systeme. Beipsielsweise \texttt{RabbitMQ} oder Apache Kafka
			\item Ereignisverarbeitung durch \textit{Event Processing Agents} (EPA): Durchsuchen den Ereignisstrom nach Mustern
		\end{itemize}
		\item Streaming Technologien
		\begin{itemize}
			\item Apache Kafka: Topic-gestützte Verteilung von Ereignisobjekten von Quellen auf Konsumenten; Zusammenfassen von Konsumenten zu \textit{Consumer Groups}
			\item Spring Cloud Stream: Framework für ereignisgesteuerte Microservices. Abstrahiert die Streaming-Middleware (beispielsweise Apache Kafka); direkte Verbindung zwischen Anwendungen möglich (steigert die Effizienz)
		\end{itemize}
	\end{itemize}
	\item \textbf{Ergeignisverarbeitung in der ConnectedCar-Domäne}
	\begin{itemize}
		\item Im Fahrzeug: Entlastung des Backends; Echtzeitanforderungen; Hochverfügbarkeit; Datenschutz
		\item Im Backend: Kombinierbarkeit mit anderen Fahrzeugen; Änderung der Verfahren; Hinzuziehen weiterer Quellen
		\item Ereignisvorverarbeitung im Fahrzeug: Entlastung von Infrastruktur/Backend; dynamische Konfigurierbarkeit durch das Backend möglich (beispielsweise durch gezielte Anfragen)
	\end{itemize}
\end{itemize}


\subsection{Analyse und Entwurf}
\begin{itemize}
	\item Domänenmodell als Grundlage zur Web-\texttt{APIs}, die für den \texttt{HazardWarningService} notwendig sind
	\item \textbf{Vorgehen}
	\begin{enumerate}
		\item Kapselung des Domänenmodells in Services
		\item Ermittlung der notwendigen Service-Operationen pro Service (statische \texttt{API}-Spezifikation)
		\item Ergänzen der dynamischen Inhalte, bei beispielsweise ablaufbeschreibende Diagramme (dynamische \texttt{API}-Spezifikation)
	\end{enumerate}
\end{itemize}



\section{Web Services with Quality}



\section{API-Spezifikationen}



\section{Scrum}



\section{Sicherheit}