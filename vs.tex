\chapter{Virtuelle Systeme}

Zusammenfassung der Vorlesung "`Virtuelle Systeme"' aus dem Wintersemester 2016.\footnote{\url{https://os.itec.kit.edu/deutsch/3257_3261.php}}

\section{Einführung}
\begin{itemize}
	\item Abstraktion: Versteckt Implementierungsdetails niedrigerer Ebenen und stellt vereinfachte Interfaces zu Ressourcen zur Verfügung \(\rightarrow\) vereinfacht das Design auf höheren Ebenen. Beispiel: Dateien als Abstraktion einer Festplatte mit Interface (\texttt{open, read, write})
	\item \textbf{Interfaces}
	\begin{itemize}
		\item Instruction Set Architectur (ISA): Betriebssystemunabhängiges Interface für den Hardwarezugriff; beispielsweise \texttt{IA-32}
		\item Application Binary Interface (ABI): Interface für den Hardwarezugriff, das vom Betriebssystem zur Verfügung gestellt wird; beispielsweise \textit{system calls}
		\item Nachteile: Eventuell schlechte Portabilität, da höhere Ebenen von entsprechenden Interfaces abhängig sind; beispielsweise ist Software an bestimmte ISAs und OSe gebunden
	\end{itemize}
\end{itemize}


\subsection{Virtualisierung}
\begin{itemize}
	\item Abstrakt: Isomorphismus zwischen Gast und Host: Gast-Operationen werden auf enstprechende Host-Operationen abgebildet
	\item \textbf{Aufgaben der Virtualisierung}
	\begin{itemize}
		\item Zuordnung von virtuellen zu realen Ressourcen
		\item Verwenden von realen Maschinenbefehlen oder System Calls um die Anweisungen aus dem Gastsystem auszuführen
	\end{itemize}
	\item \textbf{Process Virtual Machines}
	\begin{itemize}
		\item Abstrahiert \textbf{API} oder \textbf{ABI} \(\rightarrow\) simuliert ein Programm/Prozess
		\item Interaktion mit dem Host-Betriebssystem zur Laufzeit via System Calls
		\item Runtime zur Verwaltung der Gastprozesse \(\rightarrow\) Vermischung von Gast- und Hostprozessen
		\item Beispiel: \textit{Wine}
		\item Binary Translation
		\begin{itemize}
			\item Selbes Betriebssystem, verschiedene \texttt{ISAs}: Einführung einer Zwischenschicht zur Übersetzung der \texttt{ABI}-Befehle
			\item Beispiel \texttt{Digital FX!32}: Erlaubt das Ausführen von Windows-Anwendungen, die für \texttt{x86} kompiliert worden sind, auf \texttt{Alpha}-Prozessoren
			\item Beispiel \texttt{HP Dynamo}: Optimierung zur Laufzeit innerhalb der selben Umgebung
		\end{itemize}
		\item Anwendungsbeispiel Java Virtual Maschine: Spezifizierung eines high-level Interfaces. Das Betriebssystem wird als Standard-Bibliothek abstrahiert
	\end{itemize}
	\item \textbf{System Virtuelle Maschinen}
	\begin{itemize}
		\item Abstrahiert die \textbf{ISA} des Hosts als separate virtuelle Maschinen \(\rightarrow\) simuliert kompletten PC
		\item Interaktion über den \textit{Virtual Machine Monitor} (VMM)
		\item Typen
		\begin{itemize}
			\item Nativ System VM: VMM im privilegierten Modues; Gast im Benutzermodus; beispielsweise \texttt{Xen} oder \texttt{Hyper-V}
			\item Hostet System VM: VMM und Gast im Benutzermodus; beispielsweise \texttt{VirtualBox} oder \texttt{QEMU}
			\item Dual-Mode System VM: VMM teilweise im privilegierten Modus; beispielsweise \texttt{QEMU} mit \texttt{KVM}
		\end{itemize}
		\item Vorteile System VM
		\begin{itemize}
			\item Erhöhte Kompatibilität
			\item Höhere Effizienz, da mehrere virtuelle Maschinen auf einer physischen laufen können
			\item Zuverlässigkeit und Verfügbarkeit wird durch Replikation- und Migrationsmöglichkeiten erhöht
			\item Sicherheit durch Isolierung zwischen den Gästen
			\item Möglichkeiten zur System-Analyse auf \texttt{ISA}-Ebene (Debugging, Malware-Analyse, Forschung)
		\end{itemize}
	\end{itemize}
\end{itemize}



\section{Emulation}
\begin{itemize}
	\item Ziel: Implementieren von Interface/Funktionalität eines Systems auf einem anderen System
	\item \textbf{Interpretation vs. Binary Translation}
	\begin{itemize}
		\item Interpretation
		\begin{itemize}
			\item Quellinstruktion wird analysiert, in Zielinstruktion überführt und ausgeführt
			\item Einfach zu implementieren; allerdings mit hohen Ausführungskosten verbunden
		\end{itemize}
		\item Binary Translation
		\begin{itemize}
			\item Betrachtet immer einen Instruktionsblock, übersetzt diesen und cacht ihn
			\item Kmplexer; beim Start höhere Ausführungskosten; allerdings geringe Ausführungskosten
		\end{itemize}
	\end{itemize}
	\item \textbf{Aufbau einer Process VM}
	\begin{itemize}
		\item Emulation Engine: Emuliert die Instruktionen (wahlweise mittels Interpretation oder Binary Translation; verantwortlich für deren Auswahl)
		\item Profile Database: Sammelt dynamisch Informationen zum laufenden Programm \(\rightarrow\) bildet Basis für Emulationstechnikentscheidungen und Optimierung im Translater
		\item Code Cache: Verwaltet die zwischengespeicherten, bereits übersetzten Code-Fragmente. \textit{Code Cache Manager} entscheidet, ob Fragmente im Cache abgelegt werden
		\item Interpreter: Für virtuelle Quell-CPU und die Speicherverwaltung verantwortlich
	\end{itemize}
	\item Decode-Dispatch-Interpretation: Interpreter betrachter das Quell-Programm schrittweise; dekodiert die Instruktionen und auf die Dispatch-Routine auf. Diese liest/modifiziert den Gast-Zustand
	\item \textbf{Optimierungsmöglichkeiten des Interpreters}: Ausführen einer einzigen Quellinstruktion benötigt ein Vielfaches "`multiple tens"' an Instruktionen auf dem Host \(\rightarrow\) extrem ineffizient
	\begin{enumerate} % TODO
		\item Treaded Interpretation: Kopiere Dekoderlogik ans Ende von jeder Dispatch-Routine; verwende Sprungtabellen statt switch-case-Statements \(\rightarrow\) vermeidet teure Branches
		\item Predecoding: Aufbereitung der Quellinstruktionen (Opcode, Operanden, etc.) für einfachere Zugriffe auf die Instruktionen zur Laufzeit \(\rightarrow\) vereinfacht die Dekodierroutine
		\item Direct Threaded Interpretation (Kombination aus Erstgenannten): Speichere Adresse der Dispatch-Routine statt Opcode \(\rightarrow\) benötigt keine Sprungroutine und vermeidet Indirektionen 
	\end{enumerate}
	\item Dynamic Binary Translation (BDT): Benötigt keine Dispatch-Routinen; erlaubt Optimierungen der Ziel-Instruktionen
	\item \textbf{Probleme bei Binary Translation}
	\begin{itemize}
		\item Code Discovery Problem: Finden des Einsprungpunkts bei Quell-Instruktionen ggf. schwierig (Instruktionen und Opcodes unterschiedlich lange; u.U. Daten in Instruction Stream eingebettet; Padding; indirekte Sprünge \(\rightarrow\) Sprungziel erst zur Laufzeit bekannt)
		\item Code Location Problem: Fehlerhafte SIP-TIP-Beziehung (Source/Traget Instruction Pointer). Kann beispielsweise entstehen, wenn eine Quell-Instruktion auf mehrere Zielinstruktionen abgebildet werden
	\end{itemize}
	\item \textbf{Dynamic Translation}
	\begin{itemize}
		\item Zunächst Interpretation mit Code Discovery
		\item Der Code wird schrittweise übersetzt und blockweise im Code-Cache gespeichert. Zusätzlich wird das IP-Mapping im \textit{SIP-To-TIP}-Cache gespeichert
		\item Problem dabei: Wie wird der Folgeblock identifiziert? \(\rightarrow\) speichere zusätzlich den SIP zur Folgeinstruktion. Dieser kann im SIP-to-TIP-Cache nachgeschlagen werden
		\item Optimierung \textit{Translation Block Chaining}
		\begin{itemize}
			\item Vermeidet Rücksprünge zum Emulation Manager; der nächste Block wird direkt im Block davor gespeichert. Bei Sprüngen werden verschiedene mögliche Ziele gespeichert
			\item Unconditional Jump: Direkter Sprung zum nächsten Block
			\item Conditional Jump: Jeder Folgeblock wird separat gelinkt
			\item Indirect Jump: Immer zurück zum Emulation Manager
		\end{itemize}
	\end{itemize}
	\item \textbf{Code-Cache-Management}
	\begin{itemize}
		\item Herausforderungen: Variabel lange Blöcke; Abhängigkeiten zwischen Blöcken; Blöcke müssen bei Verdrängung aus dem Cache neu generiert werden \(\rightarrow\) unterscheiden sich von typischen Hardware-Caches wie CPU-Caches oder TLBs
		\item Ersetzungsstrategien
		\begin{itemize}
			\item Least Recently Used (LRU): Probleme durch Verwaltungsoverhead (Nutzungsverhalten der Blöcke); bei Verdrängung Aktualisierung der Verknüpfungen mit anderen Blöcken notwendig (Speicherung von Back-Pointern); variabel große Blöcke führen zu Cache-Fragmentierung
			\item Flush When Full (FwF)
			\begin{itemize}
				\item Vorteile: Einfach; Berücksichtigt Dependencies und Fragmentierung
				\item Nachteil: Regenerierung der gelöschten Blöcke teuer
				\item Defaulteinstellung bei \texttt{QEMU} mit 16 MB Cache
			\end{itemize}
			\item Preemptive Flush
			\begin{itemize}
				\item Viele Programme weisen Phasenverhalten auf (Initialisierung, schrittweise Berechnungen, etc.) \(\rightarrow\) Instruction Working Set wechselt
				\item Idee: Flush, wenn Phasenwechsel erkannt (an Hand Burst neuer Instruktionen)
			\end{itemize}
			\item First In First Out (FIFO)
			\begin{itemize}
				\item Der/die älteste(n) Blöcke werden entfernt
				\item Vorteile: Berücksichtigt zeitliche Lokalität; kein Verwaltungsoverhead zum Nutzungsverhalten der Blöcke (siehe LRU)
				\item Nachteil: Back-Pointer notwendig
				\item Variante Coarse-Grainied FIFO: Code-Cache wird partitioniert, es werden immer ganze Partitionen gelöscht; keine Verkettung zwischen Partitionen
			\end{itemize}
		\end{itemize}
	\end{itemize}
	\item \textbf{Gastarbeitsspeicherverwaltung}
	\begin{itemize}
		\item Gast erhält einen Teil des Adressbereichs des Hosts; zuverlässige Isolierung notwendig (Gast darf nicht auf den Speicher, den der Host für sich nutzt, zugreifen können)
		\item Runtime verwaltet Zuordnungstabelle
	\end{itemize}
	\item \textbf{Exception Handling}
	\begin{itemize}
		\item Direkt: Interpreter erkennt Exceptions und springt zu einem \textit{Runtime Trap Handler}
		\item Indirekt: Host-ISA erkennt die Exception. Signal wird durch das Host-OS an den Runtime Handler weitergegeben (beispielsweise Division durch \texttt{0})
	\end{itemize}
	\item \textbf{Operating System Calls}
	\begin{itemize}
		\item Wrapper übersetzt Quell-System-Call zu Ziel-System-Call; eventuell muss zwischen Calling Conventions übersetzt werden
		\item Manche Calls können vom Gastsystem selbst behandelt werden (beispielsweise Signal Handler Registrierung, oder Speichermanagement)
	\end{itemize}
\end{itemize}



\section{System VMs}
\begin{itemize}
	\item Ziel: Unterstützung mehrerer Gast-Betriebsssteme auf einem System
	\item Virtual Machine Monitor (VMM): "`Besitzer"' der Hardware-Ressourcen; läuft im privilegierten Modus (Gäste im Gastmodus); verwaltet Allokation/Zugriff auf die Ressourcen
	\item VMM wechselt zur Ausführung der Gäste zwischen diesen (vglbar mit Timesharing zwischen Anwendungen eines Betriebssystems). Gäste dürfen dazu weder selbst Timer-Interrupts setzen noch die echten Timer-Interrupt Werte lesen (wird vom VMM emuliert) % What? Wieso?
	\item \textbf{State Management}
	\begin{itemize}
		\item Alle Gästen benötigen individuelle (exklusive oder versteckte) Hardware-Ressourcen wie beispielsweise Festplatten (können rein virtuell sein); alle nicht-exklusiven, die virtualisiert werden, müssen entsprechend verwaltet werden (Partitionierung oder Sharing)
		\item Wechsel zwischen den States mehrerer VMs
		\begin{itemize}
			\item Indirection: Zustand der Gäste wird im RAM des VMM vorgehalten; Pointer wechselt zwischen den Gästen. Beispielsweise gut geeignet für Page Directory; ungeeignet für Registersätze % Wieso? Viele langsame Speicherzugriffe?
			\item Copying: Zustand der Gäste wird jeweils aus dem RAM des VMM in den Register Block des Prozessors kopiert. Beispielsweise gut geeignet für Registersätze; ungeeignet für Page Directory
		\end{itemize}
	\end{itemize}
	\item \textbf{Virtualisierung des Prozessors}
	\begin{itemize}
		\item Generelle Techniken
		\begin{itemize}
			\item Full Emulation: Immer möglich; ISA des Gasts muss nicht ISA des Hosts entsprechen; langsam
			\item Direct Native Execution: Nahezu native Ausführungsgeschwindigkeit; ISA des Gasts \textit{muss} der des Hosts entsprechen
		\end{itemize}
		\item Direct Native Execution
		\begin{itemize}
			\item \textit{Trap'n'emulate}: Gastinstruktionen werden direkt ausgeführt; "`Trap"' bei privilegierten Instruktionen, diese werden vom Dispatcher emuliert. Letzterer ruft die entsprechende \textit{Interpreterroutine} auf. Beispiele für pivilegierte Instruktionen: \texttt{IN}, \texttt{OUT}, \texttt{Write TLB}
			\item Aufgabenverteilung
			\begin{itemize}
				\item Dispatcher: Übergeordnete Komponente; entscheidet welche Komponente aufgerufen werden soll
				\item Allocator: Verwaltet Ressourcen, die sich die VMs teilen
				\item Interpreter Routines: Existiert pro privilegierter Instruktion; emuliert den Befehl auf virtuellen Ressourcen % TODO
			\end{itemize}
			\item Gastbetriebssystem: Da nur der VMM im Kernelmodus läuft "`fallen"' alle privilegierten Instruktionen in den VMM Dispatcher
			\item Gastanwendungen: Da \texttt{SYSCALL} auf \texttt{x86}-Systemen keine privilegierte Instruktion ist muss der VMM diese speziell abfangen, damit sie korrekt emuliert werden können
			\item Weitere wichtige Instruktionen: Instruction Types
			\begin{itemize}
				\item Definitionen
				\begin{itemize}
					\item Control sensitive instructions: Alle Instruktionen, welche die Ressourcenkonfiguration verändern. Beispiel: Page Directory Pointer (\texttt{CR3}) auf \texttt{x86} aktualisieren
					\item Behavior sensitive instructions: Alle Instruktionen, deren Verhalten/Ergebnis konfigurationsabhängig ist. Beispiel: Pop flags register (\texttt{POPF}) auf \texttt{x86}
					\item Privileged instructions: Alle Instruktionen, die trappen (müssen), wenn sie im User Mode ausgeführt werden. Beispiel: Load processor status word (\texttt{LPSW}) auf \texttt{System/370}. Vorsicht: Lehrstuhlspezifische Definition; schließt \texttt{SYSCALL} hier mit ein
					\item Innocuous instructions ("`harmlose"'): Weder control- noch behavior-sensitiv
				\end{itemize}
				\item \textit{Efficient Virtual Machines Theorem}: Alle sensitiven Instruktionen, die eine Teilmenge der privilegierten Instruktionen bilden, können effizient ausgeführt werden
				\item Critical Instructions
				\begin{itemize}
					\item Sensitiv aber nicht priviligiert. Bei \texttt{x86} gibt es beispielsweise 17
					\item Lösung: Kritische Instruktionen werden gepacht. Dazu scannt der VMM den Code des Gasts vor der Ausführung und wandelt alle kritischen Instruktionen in Traps um
					\item Umsetzung mittels \textit{Dynamic-binary-translation}-Techniken: Instruction stream wird in Blöcke aufgteilt und gepatcht. Am Ende des Blocks wird eine zusätzliche Trap eingefügt, damit der VMM die Kontrolle zurückerlangt
					\item Generelles Problem mit Traps: Sehr teuer
				\end{itemize}
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{itemize}




























