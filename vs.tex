\chapter{Virtuelle Systeme}

Zusammenfassung der Vorlesung "`Virtuelle Systeme"' aus dem Wintersemester 2016.\footnote{\url{https://os.itec.kit.edu/deutsch/3257_3261.php}}

\section{Einführung}
\begin{itemize}
	\item Abstraktion: Versteckt Implementierungsdetails niedrigerer Ebenen und stellt vereinfachte Interfaces zu Ressourcen zur Verfügung \(\rightarrow\) vereinfacht das Design auf höheren Ebenen. Beispiel: Dateien als Abstraktion einer Festplatte mit Interface (\texttt{open, read, write})
	\item \textbf{Interfaces}
	\begin{itemize}
		\item Instruction Set Architectur (ISA): Betriebssystemunabhängiges Interface für den Hardwarezugriff; beispielsweise \texttt{IA-32}
		\item Application Binary Interface (ABI): Interface für den Hardwarezugriff, das vom Betriebssystem zur Verfügung gestellt wird; beispielsweise \textit{system calls}
		\item Nachteile: Eventuell schlechte Portabilität, da höhere Ebenen von entsprechenden Interfaces abhängig sind; beispielsweise ist Software an bestimmte ISAs und OSe gebunden
	\end{itemize}
\end{itemize}


\subsection{Virtualisierung}
\begin{itemize}
	\item Abstrakt: Isomorphismus zwischen Gast und Host: Gast-Operationen werden auf enstprechende Host-Operationen abgebildet
	\item \textbf{Aufgaben der Virtualisierung}
	\begin{itemize}
		\item Zuordnung von virtuellen zu realen Ressourcen
		\item Verwenden von realen Maschinenbefehlen oder System Calls um die Anweisungen aus dem Gastsystem auszuführen
	\end{itemize}
	\item \textbf{Process Virtual Machines}
	\begin{itemize}
		\item Abstrahiert \textbf{API} oder \textbf{ABI} \(\rightarrow\) simuliert ein Programm/Prozess
		\item Interaktion mit dem Host-Betriebssystem zur Laufzeit via System Calls
		\item Runtime zur Verwaltung der Gastprozesse \(\rightarrow\) Vermischung von Gast- und Hostprozessen
		\item Beispiel: \textit{Wine}
		\item Binary Translation
		\begin{itemize}
			\item Selbes Betriebssystem, verschiedene \texttt{ISAs}: Einführung einer Zwischenschicht zur Übersetzung der \texttt{ABI}-Befehle
			\item Beispiel \texttt{Digital FX!32}: Erlaubt das Ausführen von Windows-Anwendungen, die für \texttt{x86} kompiliert worden sind, auf \texttt{Alpha}-Prozessoren
			\item Beispiel \texttt{HP Dynamo}: Optimierung zur Laufzeit innerhalb der selben Umgebung
		\end{itemize}
		\item Anwendungsbeispiel Java Virtual Maschine: Spezifizierung eines high-level Interfaces. Das Betriebssystem wird als Standard-Bibliothek abstrahiert
	\end{itemize}
	\item \textbf{System Virtuelle Maschinen}
	\begin{itemize}
		\item Abstrahiert die \textbf{ISA} des Hosts als separate virtuelle Maschinen \(\rightarrow\) simuliert kompletten PC
		\item Interaktion über den \textit{Virtual Machine Monitor} (VMM)
		\item Typen
		\begin{itemize}
			\item Nativ System VM: VMM im privilegierten Modues; Gast im Benutzermodus; beispielsweise \texttt{Xen} oder \texttt{Hyper-V}
			\item Hostet System VM: VMM und Gast im Benutzermodus; beispielsweise \texttt{VirtualBox} oder \texttt{QEMU}
			\item Dual-Mode System VM: VMM teilweise im privilegierten Modus; beispielsweise \texttt{QEMU} mit \texttt{KVM}
		\end{itemize}
		\item Vorteile System VM
		\begin{itemize}
			\item Erhöhte Kompatibilität
			\item Höhere Effizienz, da mehrere virtuelle Maschinen auf einer physischen laufen können
			\item Zuverlässigkeit und Verfügbarkeit wird durch Replikation- und Migrationsmöglichkeiten erhöht
			\item Sicherheit durch Isolierung zwischen den Gästen
			\item Möglichkeiten zur System-Analyse auf \texttt{ISA}-Ebene (Debugging, Malware-Analyse, Forschung)
		\end{itemize}
	\end{itemize}
\end{itemize}



\section{Emulation}
\begin{itemize}
	\item Ziel: Implementieren von Interface/Funktionalität eines Systems auf einem anderen System
	\item \textbf{Interpretation vs. Binary Translation}
	\begin{itemize}
		\item Interpretation
		\begin{itemize}
			\item Quellinstruktion wird analysiert, in Zielinstruktion überführt und ausgeführt
			\item Einfach zu implementieren; allerdings mit hohen Ausführungskosten verbunden
		\end{itemize}
		\item Binary Translation
		\begin{itemize}
			\item Betrachtet immer einen Instruktionsblock, übersetzt diesen und cacht ihn
			\item Kmplexer; beim Start höhere Ausführungskosten; allerdings geringe Ausführungskosten
		\end{itemize}
	\end{itemize}
	\item \textbf{Aufbau einer Process VM}
	\begin{itemize}
		\item Emulation Engine: Emuliert die Instruktionen (wahlweise mittels Interpretation oder Binary Translation; verantwortlich für deren Auswahl)
		\item Profile Database: Sammelt dynamisch Informationen zum laufenden Programm \(\rightarrow\) bildet Basis für Emulationstechnikentscheidungen und Optimierung im Translater
		\item Code Cache: Verwaltet die zwischengespeicherten, bereits übersetzten Code-Fragmente. \textit{Code Cache Manager} entscheidet, ob Fragmente im Cache abgelegt werden
		\item Interpreter: Für virtuelle Quell-CPU und die Speicherverwaltung verantwortlich
	\end{itemize}
	\item Decode-Dispatch-Interpretation: Interpreter betrachter das Quell-Programm schrittweise; dekodiert die Instruktionen und auf die Dispatch-Routine auf. Diese liest/modifiziert den Gast-Zustand
	\item \textbf{Optimierungsmöglichkeiten des Interpreters}: Ausführen einer einzigen Quellinstruktion benötigt ein Vielfaches "`multiple tens"' an Instruktionen auf dem Host \(\rightarrow\) extrem ineffizient
	\begin{enumerate} % TODO
		\item Treaded Interpretation: Kopiere Dekoderlogik ans Ende von jeder Dispatch-Routine; verwende Sprungtabellen statt switch-case-Statements \(\rightarrow\) vermeidet teure Branches
		\item Predecoding: Aufbereitung der Quellinstruktionen (Opcode, Operanden, etc.) für einfachere Zugriffe auf die Instruktionen zur Laufzeit \(\rightarrow\) vereinfacht die Dekodierroutine
		\item Direct Threaded Interpretation (Kombination aus Erstgenannten): Speichere Adresse der Dispatch-Routine statt Opcode \(\rightarrow\) benötigt keine Sprungroutine und vermeidet Indirektionen 
	\end{enumerate}
	\item Dynamic Binary Translation (BDT): Benötigt keine Dispatch-Routinen; erlaubt Optimierungen der Ziel-Instruktionen
	\item \textbf{Probleme bei Binary Translation}
	\begin{itemize}
		\item Code Discovery Problem: Finden des Einsprungpunkts bei Quell-Instruktionen ggf. schwierig (Instruktionen und Opcodes unterschiedlich lange; u.U. Daten in Instruction Stream eingebettet; Padding; indirekte Sprünge \(\rightarrow\) Sprungziel erst zur Laufzeit bekannt)
		\item Code Location Problem: Fehlerhafte SIP-TIP-Beziehung (Source/Traget Instruction Pointer). Kann beispielsweise entstehen, wenn eine Quell-Instruktion auf mehrere Zielinstruktionen abgebildet werden
	\end{itemize}
	\item \textbf{Dynamic Translation}
	\begin{itemize}
		\item Zunächst Interpretation mit Code Discovery
		\item Der Code wird schrittweise übersetzt und blockweise im Code-Cache gespeichert. Zusätzlich wird das IP-Mapping im \textit{SIP-To-TIP}-Cache gespeichert
		\item Problem dabei: Wie wird der Folgeblock identifiziert? \(\rightarrow\) speichere zusätzlich den SIP zur Folgeinstruktion. Dieser kann im SIP-to-TIP-Cache nachgeschlagen werden
		\item Optimierung \textit{Translation Block Chaining}
		\begin{itemize}
			\item Vermeidet Rücksprünge zum Emulation Manager; der nächste Block wird direkt im Block davor gespeichert. Bei Sprüngen werden verschiedene mögliche Ziele gespeichert
			\item Unconditional Jump: Direkter Sprung zum nächsten Block
			\item Conditional Jump: Jeder Folgeblock wird separat gelinkt
			\item Indirect Jump: Immer zurück zum Emulation Manager
		\end{itemize}
	\end{itemize}
	\item \textbf{Code-Cache-Management}
	\begin{itemize}
		\item Herausforderungen: Variabel lange Blöcke; Abhängigkeiten zwischen Blöcken; Blöcke müssen bei Verdrängung aus dem Cache neu generiert werden \(\rightarrow\) unterscheiden sich von typischen Hardware-Caches wie CPU-Caches oder TLBs
	\end{itemize}
\end{itemize}




























